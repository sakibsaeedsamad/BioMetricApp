package com.sssakib.biometricapp

import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import android.util.Log
import android.view.Menu
import android.view.MenuItem
import android.widget.Toast
import androidx.annotation.Nullable
import androidx.annotation.RequiresApi
import androidx.appcompat.app.ActionBarDrawerToggle
import androidx.appcompat.app.AppCompatActivity
import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt
import androidx.core.view.GravityCompat
import com.google.android.material.navigation.NavigationView
import com.google.android.material.snackbar.Snackbar
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.android.synthetic.main.app_bar_main.*
import java.security.*
import java.security.spec.ECGenParameterSpec
import java.util.*
import java.util.concurrent.Executor

@Suppress("DEPRECATED_IDENTITY_EQUALS")
class MainActivity : AppCompatActivity(), NavigationView.OnNavigationItemSelectedListener {
    private var mToBeSignedMessage: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        setSupportActionBar(toolbar)

        fab.setOnClickListener { view ->
            Snackbar.make(view!!, "Replace with your own action", Snackbar.LENGTH_LONG)
                .setAction("Action", null).show()
        }
        val toggle = ActionBarDrawerToggle(
            this,
            drawer_layout,
            toolbar,
            R.string.navigation_drawer_open,
            R.string.navigation_drawer_close
        )
        drawer_layout.addDrawerListener(toggle)
        toggle.syncState()
        nav_view.setNavigationItemSelectedListener(this)
    }

    override fun onBackPressed() {
        if (drawer_layout.isDrawerOpen(GravityCompat.START)) {
            drawer_layout.closeDrawer(GravityCompat.START)
        } else {
            super.onBackPressed()
        }
    }

    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        // Inflate the menu; this adds items to the action bar if it is present.
        menuInflater.inflate(R.menu.main, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        val id: Int = item.itemId
        return if (id == R.id.action_settings) {
            true
        } else super.onOptionsItemSelected(item)
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        // Handle navigation view item clicks here.
        val id: Int = item.itemId
        if (id == R.id.nav_register) {
            if (canAuthenticateWithStrongBiometrics()) {  // Check whether this device can authenticate with biometrics
                Log.i(MainActivity.Companion.TAG, "Try registration")
                // Generate keypair and init signature
                val signature: Signature?
                try {
                    val keyPair: KeyPair = generateKeyPair(MainActivity.Companion.KEY_NAME, true)
                    // Send public key part of key pair to the server, this public key will be used for authentication
                    mToBeSignedMessage =
                        Base64.encodeToString(keyPair.public.encoded, Base64.URL_SAFE)
                            .toString() +
                                ":" +
                                MainActivity.Companion.KEY_NAME +
                                ":" +  // Generated by the server to protect against replay attack
                                "12345"
                    signature = initSignature(MainActivity.Companion.KEY_NAME)
                } catch (e: Exception) {
                    throw RuntimeException(e)
                }

                // Create biometricPrompt
                showBiometricPrompt(signature)
            } else {
                // Cannot use biometric prompt
                Toast.makeText(this, "Cannot use biometric", Toast.LENGTH_SHORT).show()
            }
        } else if (id == R.id.nav_authenticate) {
            if (canAuthenticateWithStrongBiometrics()) {  // Check whether this device can authenticate with biometrics
                Log.i(MainActivity.Companion.TAG, "Try authentication")

                // Init signature
                val signature: Signature?
                try {
                    // Send key name and challenge to the server, this message will be verified with registered public key on the server
                    mToBeSignedMessage = (MainActivity.Companion.KEY_NAME +
                            ":" +  // Generated by the server to protect against replay attack
                            "12345")
                    signature = initSignature(MainActivity.Companion.KEY_NAME)
                } catch (e: Exception) {
                    throw RuntimeException(e)
                }

                // Create biometricPrompt
                showBiometricPrompt(signature)
            } else {
                // Cannot use biometric prompt
                Toast.makeText(this, "Cannot use biometric", Toast.LENGTH_SHORT).show()
            }
        }
        //val drawer = findViewById<DrawerLayout>(R.id.drawer_layout)
        drawer_layout.closeDrawer(GravityCompat.START)
        return true
    }


    private fun showBiometricPrompt(signature: Signature?) {
        val authenticationCallback: BiometricPrompt.AuthenticationCallback =
            authenticationCallback
        val mBiometricPrompt = BiometricPrompt(
            this,
            mainThreadExecutor, authenticationCallback
        )

        // Set prompt info
        val promptInfo: BiometricPrompt.PromptInfo = BiometricPrompt.PromptInfo.Builder()
            .setDescription("Description")
            .setTitle("Title")
            .setSubtitle("Subtitle")
            .setNegativeButtonText("Cancel")
            .build()

        // Show biometric prompt
        if (signature != null) {
            Log.i(MainActivity.Companion.TAG, "Show biometric prompt")
            mBiometricPrompt.authenticate(promptInfo, BiometricPrompt.CryptoObject(signature))
        }
    }// Error// Normally, ToBeSignedMessage and Signature are sent to the server and then verified

    // Callback for biometric authentication result
    private val authenticationCallback: BiometricPrompt.AuthenticationCallback
        get() =// Callback for biometric authentication result
            object : BiometricPrompt.AuthenticationCallback() {
                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                    Log.e(
                        MainActivity.Companion.TAG,
                        "Error code: " + errorCode + "error String: " + errString
                    )
                    super.onAuthenticationError(errorCode, errString)
                }

                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                    Log.i(MainActivity.Companion.TAG, "onAuthenticationSucceeded")
                    super.onAuthenticationSucceeded(result)
                    if (result.cryptoObject != null &&
                        result.cryptoObject!!.signature != null
                    ) {
                        try {
                            var signature: Signature? = result.cryptoObject!!.signature
                            signature?.update(mToBeSignedMessage!!.toByteArray())
                            val signatureString: String =
                                Base64.encodeToString(signature?.sign(), Base64.URL_SAFE)
                            // Normally, ToBeSignedMessage and Signature are sent to the server and then verified
                            Log.i(MainActivity.Companion.TAG, "Message: $mToBeSignedMessage")
                            Log.i(
                                MainActivity.Companion.TAG,
                                "Signature (Base64 Encoded): $signatureString"
                            )
                            Toast.makeText(
                                applicationContext,
                                "$mToBeSignedMessage:$signatureString", Toast.LENGTH_SHORT
                            ).show()
                        } catch (e: SignatureException) {
                            throw RuntimeException()
                        }
                    } else {
                        // Error
                        Toast.makeText(applicationContext, "Something wrong", Toast.LENGTH_SHORT)
                            .show()
                    }
                }

                override fun onAuthenticationFailed() {
                    super.onAuthenticationFailed()
                }
            }

    @RequiresApi(Build.VERSION_CODES.M)
    @Throws(Exception::class)
    private fun generateKeyPair(
        keyName: String,
        invalidatedByBiometricEnrollment: Boolean
    ): KeyPair {
        val keyPairGenerator: KeyPairGenerator =
            KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore")
        val builder = KeyGenParameterSpec.Builder(
            keyName,
            KeyProperties.PURPOSE_SIGN
        )
            .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
            .setDigests(
                KeyProperties.DIGEST_SHA256,
                KeyProperties.DIGEST_SHA384,
                KeyProperties.DIGEST_SHA512
            ) // Require the user to authenticate with a biometric to authorize every use of the key
            .setUserAuthenticationRequired(true)

        // Generated keys will be invalidated if the biometric templates are added more to user device
        if (Build.VERSION.SDK_INT >= 24) {
            builder.setInvalidatedByBiometricEnrollment(invalidatedByBiometricEnrollment)
        }
        keyPairGenerator.initialize(builder.build())
        return keyPairGenerator.generateKeyPair()
    }

    @Nullable
    @Throws(Exception::class)
    private fun getKeyPair(keyName: String): KeyPair? {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        if (keyStore.containsAlias(keyName)) {
            // Get public key
            val publicKey: PublicKey = keyStore.getCertificate(keyName).publicKey
            // Get private key
            val privateKey: PrivateKey = keyStore.getKey(keyName, null) as PrivateKey
            // Return a key pair
            return KeyPair(publicKey, privateKey)
        }
        return null
    }

    @Nullable
    @Throws(Exception::class)
    private fun initSignature(keyName: String): Signature? {
        val keyPair: KeyPair? = getKeyPair(keyName)
        if (keyPair != null) {
            val signature: Signature = Signature.getInstance("SHA256withECDSA")
            signature.initSign(keyPair.private)
            return signature
        }
        return null
    }

    private val mainThreadExecutor: Executor
      get() = MainThreadExecutor()

    private class MainThreadExecutor() : Executor {
        private val handler: Handler = Handler(Looper.getMainLooper())
        override fun execute(r: Runnable) {
            handler.post(r)
        }
    }

    /**
     * Indicate whether this device can authenticate the user with strong biometrics
     * @return true if there are any available strong biometric sensors and biometrics are enrolled on the device, if not, return false
     */
    private fun canAuthenticateWithStrongBiometrics(): Boolean {
        return BiometricManager.from(this)
            .canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG) === BiometricManager.BIOMETRIC_SUCCESS
    }

    companion object {
        private val TAG = MainActivity::class.java.name

        // Unique identifier of a key pair
        private val KEY_NAME: String = UUID.randomUUID().toString()
    }


}